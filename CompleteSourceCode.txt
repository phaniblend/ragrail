filepath:///E:\ragai\RAG-DEV\rag-dev-assistant\static\index.html /// /// ///
file code{
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Reference - Modern React Development Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #2c3e50;
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-align: center;
        }

        .subtitle {
            text-align: center;
            color: #7f8c8d;
            font-size: 1.2rem;
            margin-bottom: 30px;
        }

        .search-container {
            max-width: 600px;
            margin: 0 auto;
            position: relative;
        }

        .search-box {
            width: 100%;
            padding: 15px 20px;
            font-size: 16px;
            border: 2px solid #e74c3c;
            border-radius: 50px;
            outline: none;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.2);
        }

        .search-box:focus {
            border-color: #c0392b;
            box-shadow: 0 6px 25px rgba(231, 76, 60, 0.3);
        }

        .content-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 30px;
            margin-top: 40px;
        }

        .card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }

        .card h3 {
            color: #e74c3c;
            margin-bottom: 15px;
            font-size: 1.4rem;
        }

        .card p {
            color: #555;
            margin-bottom: 15px;
        }

        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            overflow-x: auto;
            margin: 10px 0;
        }

        /* Hidden Developer Interface */
        .dev-interface {
            display: none !important;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            margin-top: 30px;
            border: 2px solid #00ff88;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
        }

        .dev-interface.active {
            display: block !important;
            animation: slideIn 0.5s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .dev-title {
            color: #00ff88;
            font-size: 1.8rem;
            margin-bottom: 20px;
            text-align: center;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .input-group {
            margin-bottom: 25px;
        }

        .input-label {
            color: #00ff88;
            font-weight: bold;
            margin-bottom: 8px;
            display: block;
        }

        .dev-input {
            width: 100%;
            padding: 12px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ff88;
            border-radius: 8px;
            color: #fff;
            font-size: 16px;
            outline: none;
            transition: all 0.3s ease;
        }

        .dev-input:focus {
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.4);
            background: rgba(255, 255, 255, 0.15);
        }

        .dev-textarea {
            min-height: 100px;
            resize: vertical;
            font-family: 'Courier New', monospace;
        }

        .ask-btn {
            background: linear-gradient(45deg, #00ff88, #00cc66);
            color: #000;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-top: 20px;
        }

        .ask-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 255, 136, 0.4);
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: rgba(0, 20, 0, 0.95);
            border: 2px solid #00ff88;
            border-radius: 15px;
            width: 90%;
            max-width: 1000px;
            height: 80%;
            max-height: 800px;
            position: relative;
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.3);
            display: flex;
            flex-direction: column;
            resize: both;
            overflow: hidden;
            min-width: 600px;
            min-height: 400px;
        }

        .modal-header {
            background: rgba(0, 255, 136, 0.1);
            border-bottom: 1px solid #00ff88;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
        }

        .modal-title {
            color: #00ff88;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .modal-close {
            background: none;
            border: none;
            color: #00ff88;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.3s ease;
        }

        .modal-close:hover {
            background: rgba(0, 255, 136, 0.2);
        }

        .modal-body {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .modal-body::-webkit-scrollbar {
            width: 8px;
        }

        .modal-body::-webkit-scrollbar-track {
            background: rgba(0, 255, 136, 0.1);
            border-radius: 4px;
        }

        .modal-body::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 136, 0.3);
            border-radius: 4px;
        }

        .modal-body::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 255, 136, 0.5);
        }

        .hidden {
            display: none;
        }

        /* Resize handle */
        .modal-content::after {
            content: '';
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, transparent 50%, #00ff88 50%);
            cursor: se-resize;
            border-bottom-right-radius: 15px;
        }

        /* Loading spinner */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0, 255, 136, 0.3);
            border-radius: 50%;
            border-top-color: #00ff88;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚öõÔ∏è React Reference</h1>
            <p class="subtitle">Your comprehensive guide to modern React development</p>
            
            <div class="search-container">
                <input 
                    type="text" 
                    class="search-box" 
                    id="mainSearch"
                    placeholder="Search React documentation, hooks, patterns..."
                    autocomplete="off"
                >
            </div>
        </header>

        <!-- Fake React Documentation Content -->
        <div id="fakeContent" class="content-grid">
            <div class="card">
                <h3>ü™ù React Hooks</h3>
                <p>Learn about the power of React Hooks and how they revolutionize component state management.</p>
                <div class="code-block">const [count, setCount] = useState(0);

useEffect(() => {
  document.title = `Count: ${count}`;
}, [count]);</div>
                <p>Hooks let you use state and lifecycle features without writing class components.</p>
            </div>

            <div class="card">
                <h3>üîÑ Component Lifecycle</h3>
                <p>Understanding the React component lifecycle is crucial for building efficient applications.</p>
                <div class="code-block">useEffect(() => {
  // Component did mount
  const timer = setInterval(() => {
    setTime(new Date());
  }, 1000);

  return () => {
    // Component will unmount
    clearInterval(timer);
  };
}, []);</div>
                <p>Use useEffect to handle side effects and cleanup in functional components.</p>
            </div>

            <div class="card">
                <h3>üéØ Context API</h3>
                <p>Share state across your component tree without prop drilling using React Context.</p>
                <div class="code-block">const ThemeContext = createContext();

function App() {
  return (
    &lt;ThemeContext.Provider value="dark"&gt;
      &lt;Header /&gt;
      &lt;Main /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}</div>
                <p>Context provides a way to pass data through the component tree without having to pass props down manually.</p>
            </div>

            <div class="card">
                <h3>‚ö° Performance Optimization</h3>
                <p>Optimize your React applications with memoization and lazy loading techniques.</p>
                <div class="code-block">const MemoizedComponent = memo(({ data }) => {
  return &lt;div&gt;{data.title}&lt;/div&gt;;
});

const LazyComponent = lazy(() => 
  import('./ExpensiveComponent')
);</div>
                <p>Use React.memo, useMemo, and useCallback to prevent unnecessary re-renders.</p>
            </div>

            <div class="card">
                <h3>üõ†Ô∏è Custom Hooks</h3>
                <p>Create reusable logic with custom hooks to keep your components clean and focused.</p>
                <div class="code-block">function useLocalStorage(key, initialValue) {
  const [value, setValue] = useState(() => {
    const item = window.localStorage.getItem(key);
    return item ? JSON.parse(item) : initialValue;
  });

  const setStoredValue = useCallback((newValue) => {
    setValue(newValue);
    window.localStorage.setItem(key, JSON.stringify(newValue));
  }, [key]);

  return [value, setStoredValue];
}</div>
                <p>Custom hooks enable you to extract component logic into reusable functions.</p>
            </div>

            <div class="card">
                <h3>üé® Styling Solutions</h3>
                <p>Explore modern approaches to styling React components with CSS-in-JS and utility frameworks.</p>
                <div class="code-block">// Styled Components
const Button = styled.button`
  background: ${props => props.primary ? 'blue' : 'gray'};
  color: white;
  padding: 10px 20px;
  border: none;
  border-radius: 4px;
`;

// Tailwind CSS
&lt;button className="bg-blue-500 text-white px-4 py-2 rounded"&gt;
  Click me
&lt;/button&gt;</div>
                <p>Choose from various styling solutions based on your project needs and preferences.</p>
            </div>
        </div>

        <!-- Hidden Developer Interface -->
        <div id="devInterface" class="dev-interface">
            <h2 class="dev-title">üîß React Code Analyzer</h2>
            
            <div class="input-group">
                <label class="input-label">üîç Search Query (Visible)</label>
                <input 
                    type="text" 
                    class="dev-input" 
                    id="searchQuery"
                    placeholder="Why is my useEffect hook re-running infinitely?"
                >
            </div>

            <div class="input-group">
                <label class="input-label">üé≠ System Instructions (Hidden Logic)</label>
                <textarea 
                    class="dev-input dev-textarea" 
                    id="obfuscatedPrompt"
                    placeholder="Act as a senior React developer with 10+ years experience. Analyze the code and provide detailed explanations with best practices..."
                ></textarea>
            </div>

            <div class="input-group">
                <label class="input-label">üìÅ Consolidated Codebase (Paste crawler output)</label>
                <textarea 
                    class="dev-input dev-textarea" 
                    id="codebaseInput"
                    placeholder="Paste the output from your crawler.js script here...

///////// src/components/Header.tsx ://////
import React from 'react';
// ... your code content
///

///////// src/utils/api.js ://////  
export const fetchData = () => {
// ... your code content
///

... (continue pasting all the consolidated code)"
                    style="min-height: 200px; font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.4; background: rgba(0, 50, 0, 0.3);"
                ></textarea>
                <div style="text-align: right; color: #00ff88; font-size: 12px; margin-top: 5px;">
                    <span id="codebaseCounter">0</span> characters
                </div>
                <small style="color: #888; font-style: italic;">
                    Run: <code style="color: #00ff88;">node crawler.js ./your-project output.txt</code> then copy and paste the content here
                </small>
            </div>

            <button class="ask-btn" onclick="analyzeCode()">
                üöÄ Analyze Code
            </button>
        </div>
    </div>

    <!-- Results Modal -->
    <div id="resultsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">üìã Code Analysis Results</div>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body" id="modalOutput">
                Analysis results will appear here...
            </div>
        </div>
    </div>

    <script>
        // Secret passphrase to unlock developer interface
        const SECRET_PASSPHRASE = "devmode2024";
        
        const mainSearch = document.getElementById('mainSearch');
        const fakeContent = document.getElementById('fakeContent');
        const devInterface = document.getElementById('devInterface');
        const codebaseInput = document.getElementById('codebaseInput');
        const codebaseCounter = document.getElementById('codebaseCounter');
        const resultsModal = document.getElementById('resultsModal');
        const modalOutput = document.getElementById('modalOutput');
        
        // Listen for secret passphrase
        mainSearch.addEventListener('input', function(e) {
            const value = e.target.value.toLowerCase().trim();
            
            if (value === SECRET_PASSPHRASE) {
                fakeContent.style.display = 'none';
                devInterface.classList.add('active');
                mainSearch.style.display = 'none';
                
                setTimeout(() => {
                    mainSearch.value = '';
                }, 100);
            }
        });
        
        // Character counter for codebase input
        codebaseInput.addEventListener('input', function() {
            const count = this.value.length;
            codebaseCounter.textContent = count.toLocaleString();
            
            // Change color based on size
            if (count > 5000000) { // 5MB
                codebaseCounter.style.color = '#ff4444';
            } else if (count > 1000000) { // 1MB
                codebaseCounter.style.color = '#ffaa00';
            } else {
                codebaseCounter.style.color = '#00ff88';
            }
            
            // Auto-resize textarea
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 400) + 'px';
        });

        // Modal functions
        function openModal() {
            resultsModal.classList.add('show');
        }

        function closeModal() {
            resultsModal.classList.remove('show');
        }

        // Close modal when clicking outside
        resultsModal.addEventListener('click', function(e) {
            if (e.target === resultsModal) {
                closeModal();
            }
        });

        // Make modal draggable
        let isDragging = false;
        let currentX, currentY, initialX, initialY;

        document.querySelector('.modal-header').addEventListener('mousedown', function(e) {
            isDragging = true;
            initialX = e.clientX;
            initialY = e.clientY;
        });

        document.addEventListener('mousemove', function(e) {
            if (isDragging) {
                const modal = document.querySelector('.modal-content');
                currentX = e.clientX - initialX;
                currentY = e.clientY - initialY;
                modal.style.transform = `translate(${currentX}px, ${currentY}px)`;
            }
        });

        document.addEventListener('mouseup', function() {
            isDragging = false;
        });
        
        // Analyze code function with TRUE stealth network calls
        async function analyzeCode() {
            const searchQuery = document.getElementById('searchQuery').value;
            const obfuscatedPrompt = document.getElementById('obfuscatedPrompt').value;
            const codebaseText = codebaseInput.value.trim();
            
            if (!searchQuery) {
                alert('Please enter a search query');
                return;
            }
            
            if (!codebaseText) {
                alert('Please paste your consolidated codebase');
                return;
            }
            
            if (codebaseText.length < 100) {
                alert('Codebase seems too small. Make sure you pasted the full output from crawler.js');
                return;
            }
            
            // Show modal with loading
            openModal();
            modalOutput.innerHTML = '<div class="loading-spinner"></div>Processing your code analysis...\n\nPlease wait while we examine your project structure and patterns.';
            
            try {
                // TRUE STEALTH MODE: Safe encoding for special characters
const stealthPayload = {
    q: searchQuery,  // Only this appears innocent
    _session: btoa(unescape(encodeURIComponent(JSON.stringify({  // Safe encoding
        prompt: obfuscatedPrompt || 'You are a helpful senior software developer assistant.',
        codebase: codebaseText
    }))))
};
                
                // Call with innocent-looking endpoint
                const response = await fetch('/api/search', {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'User-Agent': 'Mozilla/5.0 (Documentation Search)',
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    body: JSON.stringify(stealthPayload)
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Decode the hidden response
                let result;
                if (data.metadata) {
                    try {
                        result = atob(data.metadata);
                    } catch {
                        result = data.results || 'No results found';
                    }
                } else {
                    result = data.results || 'No results found';
                }

                // Clean response - remove any AI/Claude references
                result = result.replace(/Claude/g, 'React Expert');
                result = result.replace(/\*Powered by Claude.*?\*/g, '');
                result = result.replace(/\*Analyzed.*?characters.*?\*/g, '');
                result = result.replace(/ü§ñ/g, '‚öõÔ∏è');
                result = result.replace(/# üöÄ Claude Analysis/g, '# üöÄ Code Analysis');
                result = result.replace(/# üöÄ Codebase Analysis/g, '# üöÄ Code Analysis');
                
                modalOutput.textContent = result;
                
            } catch (error) {
                console.error('Error:', error);
                modalOutput.textContent = `‚ùå Error: ${error.message}\n\nPlease check if the backend is running and try again.`;
            }
        }
        
        // Fake search functionality for public interface
        mainSearch.addEventListener('input', function(e) {
            const value = e.target.value.toLowerCase();
            
            if (value === SECRET_PASSPHRASE.toLowerCase()) return;
            
            if (value.length > 2 && value !== SECRET_PASSPHRASE.toLowerCase()) {
                const cards = document.querySelectorAll('.card');
                cards.forEach(card => {
                    const text = card.textContent.toLowerCase();
                    if (text.includes(value)) {
                        card.style.border = '2px solid #e74c3c';
                        card.style.background = 'rgba(231, 76, 60, 0.1)';
                    } else {
                        card.style.border = 'none';
                        card.style.background = 'rgba(255, 255, 255, 0.95)';
                    }
                });
            } else {
                const cards = document.querySelectorAll('.card');
                cards.forEach(card => {
                    card.style.border = 'none';
                    card.style.background = 'rgba(255, 255, 255, 0.95)';
                });
            }
        });
        
        // Double-click to return to public interface
        devInterface.addEventListener('dblclick', function() {
            fakeContent.style.display = 'grid';
            devInterface.classList.remove('active');
            mainSearch.style.display = 'block';
            closeModal();
        });
    </script>
</body>
</html>
}

filepath:///E:\ragai\RAG-DEV\rag-dev-assistant\modules\chromadb_store.py /// /// ///
file code{
import chromadb
from chromadb.config import Settings
import os
import uuid
from typing import List, Dict, Optional
import logging

logger = logging.getLogger(__name__)

class CodeVectorStore:
    def __init__(self, persist_directory: str = "data/vector_store"):
        """Initialize ChromaDB with persistence"""
        try:
            # Ensure directory exists
            os.makedirs(persist_directory, exist_ok=True)
            
            # Initialize ChromaDB client with persistence
            self.client = chromadb.PersistentClient(
                path=persist_directory,
                settings=Settings(
                    anonymized_telemetry=False,
                    allow_reset=True
                )
            )
            
            self.collection_name = "react_code_chunks"
            self.collection = self._get_or_create_collection()
            
            logger.info(f"ChromaDB initialized with persistence at {persist_directory}")
            
        except Exception as e:
            logger.error(f"Failed to initialize ChromaDB: {e}")
            raise

    def _get_or_create_collection(self):
        """Get existing collection or create new one"""
        try:
            # Try to get existing collection
            collection = self.client.get_collection(self.collection_name)
            logger.info(f"Using existing collection: {self.collection_name}")
        except:
            # Create new collection
            collection = self.client.create_collection(
                name=self.collection_name,
                metadata={"description": "React code chunks with embeddings"}
            )
            logger.info(f"Created new collection: {self.collection_name}")
        
        return collection

    def store_chunks(self, chunks: List[Dict], session_id: Optional[str] = None) -> str:
        """
        Store code chunks in the vector database
        Returns session_id for future retrieval
        """
        if not chunks:
            logger.warning("No chunks to store")
            return ""
        
        if not session_id:
            session_id = str(uuid.uuid4())
        
        try:
            # Prepare data for ChromaDB
            documents = []
            embeddings = []
            metadatas = []
            ids = []
            
            for i, chunk in enumerate(chunks):
                # Create unique ID
                chunk_id = f"{session_id}_{i}"
                
                # Document text (what gets searched)
                doc_text = f"{chunk['filename']}\n{chunk['text']}"
                
                # Metadata (additional info)
                metadata = {
                    'filename': chunk['filename'],
                    'start_line': chunk.get('start_line', 0),
                    'end_line': chunk.get('end_line', 0),
                    'language': chunk.get('language', 'javascript'),
                    'type': chunk.get('type', 'code_block'),
                    'session_id': session_id
                }
                
                documents.append(doc_text)
                embeddings.append(chunk['embedding'])
                metadatas.append(metadata)
                ids.append(chunk_id)
            
            # Store in ChromaDB
            self.collection.add(
                documents=documents,
                embeddings=embeddings,
                metadatas=metadatas,
                ids=ids
            )
            
            logger.info(f"Stored {len(chunks)} chunks with session_id: {session_id}")
            return session_id
            
        except Exception as e:
            logger.error(f"Failed to store chunks: {e}")
            raise

    def search_similar_chunks(self, query: str, session_id: str, top_k: int = 5) -> List[Dict]:
        """
        Search for similar code chunks using semantic similarity
        """
        try:
            # Import embedder to encode query
            from .embedder import get_embedder
            embedder = get_embedder()
            
            # Encode the query
            query_embedding = embedder.model.encode([query])[0].tolist()
            
            # Search in ChromaDB
            results = self.collection.query(
                query_embeddings=[query_embedding],
                n_results=top_k,
                where={"session_id": session_id}  # Filter by session
            )
            
            # Format results
            chunks = []
            if results['documents'] and results['documents'][0]:
                for i in range(len(results['documents'][0])):
                    chunk = {
                        'text': results['documents'][0][i],
                        'metadata': results['metadatas'][0][i],
                        'distance': results['distances'][0][i] if results['distances'] else 0,
                        'filename': results['metadatas'][0][i]['filename'],
                        'type': results['metadatas'][0][i]['type'],
                        'start_line': results['metadatas'][0][i]['start_line'],
                        'end_line': results['metadatas'][0][i]['end_line']
                    }
                    chunks.append(chunk)
            
            logger.info(f"Found {len(chunks)} similar chunks for query: {query[:50]}...")
            return chunks
            
        except Exception as e:
            logger.error(f"Search failed: {e}")
            return []

    def get_session_stats(self, session_id: str) -> Dict:
        """Get statistics for a session"""
        try:
            results = self.collection.get(
                where={"session_id": session_id}
            )
            
            total_chunks = len(results['ids']) if results['ids'] else 0
            
            # Count by file type
            file_types = {}
            if results['metadatas']:
                for metadata in results['metadatas']:
                    file_type = metadata.get('type', 'unknown')
                    file_types[file_type] = file_types.get(file_type, 0) + 1
            
            return {
                'session_id': session_id,
                'total_chunks': total_chunks,
                'file_types': file_types
            }
            
        except Exception as e:
            logger.error(f"Failed to get session stats: {e}")
            return {'session_id': session_id, 'total_chunks': 0, 'file_types': {}}

    def cleanup_old_sessions(self, keep_recent: int = 10):
        """Clean up old sessions to save space"""
        try:
            # Get all sessions
            all_results = self.collection.get()
            if not all_results['metadatas']:
                return
            
            # Group by session_id
            sessions = {}
            for metadata in all_results['metadatas']:
                session_id = metadata.get('session_id')
                if session_id:
                    if session_id not in sessions:
                        sessions[session_id] = []
                    sessions[session_id].append(metadata)
            
            # Keep only recent sessions
            session_ids = list(sessions.keys())
            if len(session_ids) > keep_recent:
                old_sessions = session_ids[:-keep_recent]
                
                for old_session in old_sessions:
                    # Delete chunks from old session
                    self.collection.delete(
                        where={"session_id": old_session}
                    )
                    logger.info(f"Cleaned up old session: {old_session}")
                    
        except Exception as e:
            logger.warning(f"Cleanup failed: {e}")

    def reset_database(self):
        """Reset the entire database (use with caution!)"""
        try:
            self.client.delete_collection(self.collection_name)
            self.collection = self._get_or_create_collection()
            logger.info("Database reset successfully")
        except Exception as e:
            logger.error(f"Failed to reset database: {e}")

# Global instance
_vector_store = None

def get_vector_store():
    """Get or create the global vector store instance"""
    global _vector_store
    if _vector_store is None:
        _vector_store = CodeVectorStore()
    return _vector_store
}

filepath:///E:\ragai\RAG-DEV\rag-dev-assistant\modules\retriever.py /// /// ///
file code{
import re
from typing import List, Dict, Optional
import logging

logger = logging.getLogger(__name__)

class CodeRetriever:
    def __init__(self):
        """Initialize the code retriever"""
        self.react_keywords = {
            'hooks': ['useState', 'useEffect', 'useContext', 'useReducer', 'useMemo', 'useCallback', 'useRef'],
            'lifecycle': ['componentDidMount', 'componentWillUnmount', 'componentDidUpdate'],
            'patterns': ['HOC', 'render props', 'context', 'provider', 'consumer'],
            'issues': ['infinite loop', 're-render', 'memory leak', 'stale closure', 'dependency array']
        }

    def enhance_query(self, query: str) -> List[str]:
        """
        Enhance the user query with related terms for better retrieval
        """
        enhanced_queries = [query]
        query_lower = query.lower()
        
        # Add React-specific enhancements
        if 'useeffect' in query_lower:
            enhanced_queries.extend([
                query + ' dependency array',
                query + ' cleanup function',
                'useEffect infinite loop'
            ])
        
        if 'usestate' in query_lower:
            enhanced_queries.extend([
                query + ' state update',
                query + ' functional update',
                'useState asynchronous'
            ])
        
        if 'infinite' in query_lower or 'loop' in query_lower:
            enhanced_queries.extend([
                'useEffect dependency array',
                'missing dependencies',
                'useCallback memoization'
            ])
        
        if 'render' in query_lower:
            enhanced_queries.extend([
                'React.memo optimization',
                'useMemo performance',
                'unnecessary re-render'
            ])
        
        # Add TypeScript specific terms
        if any(ts_term in query_lower for ts_term in ['type', 'interface', 'generic']):
            enhanced_queries.extend([
                query + ' TypeScript',
                query + ' type definition'
            ])
        
        return enhanced_queries

    def retrieve_relevant_chunks(self, query: str, session_id: str, max_chunks: int = 8) -> List[Dict]:
        """
        Retrieve the most relevant code chunks for a query
        """
        try:
            from .chromadb_store import get_vector_store
            vector_store = get_vector_store()
            
            # Enhance the query
            enhanced_queries = self.enhance_query(query)
            
            all_chunks = []
            seen_chunks = set()
            
            # Search with each enhanced query
            for enhanced_query in enhanced_queries[:3]:  # Limit to avoid too many searches
                chunks = vector_store.search_similar_chunks(
                    enhanced_query, 
                    session_id, 
                    top_k=max_chunks
                )
                
                # Add unique chunks
                for chunk in chunks:
                    chunk_key = f"{chunk['filename']}:{chunk['start_line']}"
                    if chunk_key not in seen_chunks:
                        chunk['relevance_score'] = self._calculate_relevance(query, chunk)
                        all_chunks.append(chunk)
                        seen_chunks.add(chunk_key)
            
            # Sort by relevance and distance
            all_chunks.sort(key=lambda x: (x['relevance_score'], -x['distance']), reverse=True)
            
            # Return top chunks
            result_chunks = all_chunks[:max_chunks]
            
            logger.info(f"Retrieved {len(result_chunks)} relevant chunks for query: {query[:50]}...")
            return result_chunks
            
        except Exception as e:
            logger.error(f"Retrieval failed: {e}")
            return []

    def _calculate_relevance(self, query: str, chunk: Dict) -> float:
        """
        Calculate relevance score based on query and chunk content
        """
        score = 0.0
        query_lower = query.lower()
        chunk_text = chunk['text'].lower()
        chunk_type = chunk['metadata'].get('type', '')
        
        # Exact keyword matches
        query_words = query_lower.split()
        for word in query_words:
            if word in chunk_text:
                score += 1.0
        
        # React-specific bonuses
        if 'useeffect' in query_lower and 'useeffect' in chunk_text:
            score += 2.0
        
        if 'usestate' in query_lower and 'usestate' in chunk_text:
            score += 2.0
        
        if 'infinite' in query_lower and ('dependency' in chunk_text or 'useeffect' in chunk_text):
            score += 1.5
        
        # Type-based bonuses
        if chunk_type == 'react_hook' and any(hook in query_lower for hook in ['hook', 'useeffect', 'usestate']):
            score += 1.0
        
        if chunk_type == 'react_component' and 'component' in query_lower:
            score += 1.0
        
        if chunk_type == 'typescript_definition' and any(ts_term in query_lower for ts_term in ['type', 'interface']):
            score += 1.0
        
        return score

    def format_context_for_ai(self, chunks: List[Dict], query: str) -> str:
        """
        Format retrieved chunks into context for the AI model
        """
        if not chunks:
            return "No relevant code found."
        
        context_parts = []
        context_parts.append(f"## Relevant Code for Query: '{query}'\n")
        
        for i, chunk in enumerate(chunks, 1):
            filename = chunk['filename']
            start_line = chunk['metadata'].get('start_line', 0)
            end_line = chunk['metadata'].get('end_line', 0)
            chunk_type = chunk['metadata'].get('type', 'code')
            
            # Extract just the code part (remove filename prefix)
            text_lines = chunk['text'].split('\n')
            code_text = '\n'.join(text_lines[1:]) if text_lines[0] == filename else chunk['text']
            
            context_parts.append(f"### {i}. {filename} (lines {start_line}-{end_line}) - {chunk_type}")
            context_parts.append(f"```{chunk['metadata'].get('language', 'javascript')}")
            context_parts.append(code_text.strip())
            context_parts.append("```\n")
        
        return '\n'.join(context_parts)

    def get_context_summary(self, chunks: List[Dict]) -> Dict:
        """
        Get a summary of the retrieved context
        """
        if not chunks:
            return {'total_chunks': 0, 'files': [], 'types': []}
        
        files = list(set(chunk['filename'] for chunk in chunks))
        types = list(set(chunk['metadata'].get('type', 'unknown') for chunk in chunks))
        
        return {
            'total_chunks': len(chunks),
            'files': files,
            'types': types,
            'average_relevance': sum(chunk.get('relevance_score', 0) for chunk in chunks) / len(chunks)
        }

# Global instance
_retriever = None

def get_retriever():
    """Get or create the global retriever instance"""
    global _retriever
    if _retriever is None:
        _retriever = CodeRetriever()
    return _retriever
}

filepath:///E:\ragai\RAG-DEV\rag-dev-assistant\app.py /// /// ///
file code{
from flask import Flask, render_template, request, jsonify, send_from_directory
from flask_cors import CORS
import os
import logging
import base64
import json
import anthropic
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Create Flask app
app = Flask(__name__, static_folder='static')
CORS(app)

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@app.route('/')
def index():
    """Serve the main HTML page"""
    return send_from_directory('static', 'index.html')

@app.route('/ask', methods=['POST'])
def ask():
    """Claude-powered endpoint"""
    try:
        data = request.get_json()
        query = data.get("query", "")
        codebase = data.get("codebase", "")
        obfuscated = data.get("obfuscated", "You are a helpful senior React developer.")
        
        logger.info(f"Processing query: {query}")
        logger.info(f"Codebase length: {len(codebase)} characters")
        
        if not query:
            return jsonify({'error': 'Query is required'}), 400
            
        if not codebase:
            return jsonify({'error': 'Codebase is required'}), 400
        
        # Initialize Anthropic client
        api_key = os.getenv('ANTHROPIC_API_KEY')
        if not api_key:
            result = "‚ùå Claude API key not found. Please set ANTHROPIC_API_KEY."
            encoded = base64.b64encode(result.encode()).decode()
            return jsonify({"answer": encoded}), 500
        
        client = anthropic.Anthropic(api_key=api_key)
        
        # Enhanced prompt focusing on actual codebase
        prompt = f"""You are an expert React/TypeScript developer analyzing a real codebase.

DEVELOPER QUESTION: {query}

ACTUAL CODEBASE TO ANALYZE:
{codebase[:8000]}

ANALYSIS INSTRUCTIONS:
1. Focus specifically on the provided codebase content above
2. Answer the developer's question: "{query}" 
3. Reference specific files, functions, or patterns you see in the code
4. Provide actionable insights based on the actual code structure
5. If the question relates to useEffect, look for actual useEffect usage in the provided code

{obfuscated}

Analyze the ACTUAL codebase provided and answer the specific question."""

        # Call Claude
        logger.info("ü§ñ Calling Claude...")
        message = client.messages.create(
            model="claude-3-5-sonnet-20241022",
            max_tokens=3000,
            temperature=0.1,
            messages=[{"role": "user", "content": prompt}]
        )
        
        ai_response = message.content[0].text
        logger.info("‚úÖ Claude response received")
        
        # Format response
        result = f"""# üöÄ Codebase Analysis

**Your Question:** {query}

**Analysis of Your Code:**

{ai_response}

---

*Analyzed {len(codebase):,} characters ‚Ä¢ Powered by Claude 3.5 Sonnet* ü§ñ"""

        # Base64 encode
        encoded = base64.b64encode(result.encode()).decode()
        return jsonify({"answer": encoded})
        
    except Exception as e:
        logger.error(f"Error: {str(e)}")
        result = f"‚ùå Error: {str(e)}"
        encoded = base64.b64encode(result.encode()).decode()
        return jsonify({"answer": encoded}), 500

@app.route('/api/search', methods=['POST'])
def api_search():
    """Stealth endpoint that looks like documentation search"""
    try:
        data = request.get_json()
        query = data.get('q', '')  # Visible query
        session_data = data.get('_session', '')  # Hidden payload
        
        logger.info(f"Documentation search: {query}")
        
        if not session_data:
            # Return fake documentation results
            return jsonify({
                'results': f"React documentation results for: {query}",
                'count': 0
            })
        
        # Decode hidden payload
        try:
            decoded = base64.b64decode(session_data).decode('utf-8')
            hidden_data = json.loads(decoded)
            obfuscated = hidden_data.get('prompt', '')
            codebase = hidden_data.get('codebase', '')
        except Exception as decode_error:
            logger.error(f"Decode error: {decode_error}")
            return jsonify({'error': 'Invalid session data'}), 400
        
        # Call Claude (same logic as /ask)
        api_key = os.getenv('ANTHROPIC_API_KEY')
        if not api_key:
            result = "‚ùå Service temporarily unavailable."
            encoded = base64.b64encode(result.encode()).decode()
            return jsonify({'results': query, 'metadata': encoded})
        
        client = anthropic.Anthropic(api_key=api_key)
        
        prompt = f"""You are an expert React developer analyzing a codebase.

QUESTION: {query}

CODEBASE:
{codebase[:8000]}

Provide detailed analysis focusing on the specific question about this codebase."""

        message = client.messages.create(
            model="claude-3-5-sonnet-20241022",
            max_tokens=3000,
            temperature=0.1,
            messages=[{"role": "user", "content": prompt}]
        )
        
        result = f"""# Code Analysis

**Question:** {query}

{message.content[0].text}

---
*Analysis complete*"""
        
        encoded = base64.b64encode(result.encode()).decode()
        return jsonify({
            'results': f"Documentation search for: {query}",
            'count': 1,
            'metadata': encoded
        })
        
    except Exception as e:
        logger.error(f"Error: {str(e)}")
        result = f"‚ùå Error: {str(e)}"
        encoded = base64.b64encode(result.encode()).decode()
        return jsonify({'results': 'Error', 'metadata': encoded}), 500

@app.route('/health')
def health_check():
    """Health check"""
    return jsonify({'status': 'healthy', 'claude_key': os.getenv('ANTHROPIC_API_KEY') is not None})

if __name__ == '__main__':
    print(f"üîë Claude API Key: {'‚úÖ Set' if os.getenv('ANTHROPIC_API_KEY') else '‚ùå Missing'}")
    app.run(host='0.0.0.0', port=5000, debug=True)
}

filepath:///E:\ragai\RAG-DEV\rag-dev-assistant\modules\embedder.py /// /// ///
file code{
import re
import base64
from typing import List, Dict, Tuple
from sentence_transformers import SentenceTransformer
import logging

logger = logging.getLogger(__name__)

class CodeEmbedder:
    def __init__(self, model_name="all-MiniLM-L6-v2"):
        """Initialize the code embedder with a lightweight model"""
        try:
            self.model = SentenceTransformer(model_name)
            logger.info(f"Loaded embedding model: {model_name}")
        except Exception as e:
            logger.error(f"Failed to load embedding model: {e}")
            raise

    def smart_chunk_code(self, code: str, filename: str, max_chunk_size: int = 500) -> List[Dict]:
        """
        Intelligently chunk code by functions, classes, and logical blocks
        """
        chunks = []
        
        # Language detection based on file extension
        if filename.endswith(('.tsx', '.jsx')):
            lang = 'jsx'
        elif filename.endswith('.ts'):
            lang = 'typescript'
        else:
            lang = 'javascript'
        
        # Split by functions, classes, and React components
        patterns = [
            r'(function\s+\w+\s*\([^)]*\)\s*\{[^}]*\})',  # Functions
            r'(const\s+\w+\s*=\s*\([^)]*\)\s*=>\s*\{[^}]*\})',  # Arrow functions
            r'(class\s+\w+[^{]*\{[^}]*\})',  # Classes
            r'(export\s+(default\s+)?function\s+\w+[^{]*\{[^}]*\})',  # Exported functions
            r'(export\s+const\s+\w+\s*=[^;]*;)',  # Exported constants
            r'(interface\s+\w+\s*\{[^}]*\})',  # TypeScript interfaces
            r'(type\s+\w+\s*=[^;]*;)',  # TypeScript types
        ]
        
        lines = code.split('\n')
        current_chunk = []
        current_size = 0
        
        for i, line in enumerate(lines):
            line_size = len(line)
            
            # Check if this line starts a new logical block
            is_new_block = any(re.match(pattern, line.strip()) for pattern in [
                r'function\s+\w+',
                r'const\s+\w+\s*=\s*\(',
                r'class\s+\w+',
                r'export\s+',
                r'interface\s+\w+',
                r'type\s+\w+',
            ])
            
            # If adding this line would exceed chunk size and we have content, create a chunk
            if current_size + line_size > max_chunk_size and current_chunk:
                chunk_text = '\n'.join(current_chunk)
                if chunk_text.strip():
                    chunks.append({
                        'text': chunk_text,
                        'filename': filename,
                        'start_line': i - len(current_chunk) + 1,
                        'end_line': i,
                        'language': lang,
                        'type': self._detect_chunk_type(chunk_text)
                    })
                current_chunk = []
                current_size = 0
            
            current_chunk.append(line)
            current_size += line_size
        
        # Add the last chunk
        if current_chunk:
            chunk_text = '\n'.join(current_chunk)
            if chunk_text.strip():
                chunks.append({
                    'text': chunk_text,
                    'filename': filename,
                    'start_line': len(lines) - len(current_chunk) + 1,
                    'end_line': len(lines),
                    'language': lang,
                    'type': self._detect_chunk_type(chunk_text)
                })
        
        logger.info(f"Created {len(chunks)} chunks from {filename}")
        return chunks

    def _detect_chunk_type(self, code: str) -> str:
        """Detect the type of code chunk"""
        code_lower = code.lower()
        
        if 'useeffect' in code_lower or 'usestate' in code_lower:
            return 'react_hook'
        elif 'function' in code_lower and 'component' in code_lower:
            return 'react_component'
        elif 'class' in code_lower and 'extends' in code_lower:
            return 'class_component'
        elif 'interface' in code_lower or 'type' in code_lower:
            return 'typescript_definition'
        elif 'export' in code_lower:
            return 'module_export'
        elif 'import' in code_lower:
            return 'import_statement'
        else:
            return 'code_block'

    def embed_chunks(self, chunks: List[Dict]) -> List[Dict]:
        """Generate embeddings for code chunks"""
        try:
            # Prepare texts for embedding
            texts = []
            for chunk in chunks:
                # Create context-rich text for better embeddings
                context_text = f"File: {chunk['filename']}\nType: {chunk['type']}\nCode:\n{chunk['text']}"
                texts.append(context_text)
            
            # Generate embeddings
            logger.info(f"Generating embeddings for {len(texts)} chunks...")
            embeddings = self.model.encode(texts, show_progress_bar=True)
            
            # Add embeddings to chunks
            for i, chunk in enumerate(chunks):
                chunk['embedding'] = embeddings[i].tolist()
            
            logger.info("Successfully generated embeddings")
            return chunks
            
        except Exception as e:
            logger.error(f"Failed to generate embeddings: {e}")
            raise

    def process_uploaded_files(self, files_data: List[Dict]) -> List[Dict]:
        """
        Process uploaded files and return chunks with embeddings
        files_data: List of {name: str, content: str (base64)}
        """
        all_chunks = []
        
        for file_data in files_data:
            filename = file_data['name']
            
            # Skip non-React files
            if not filename.endswith(('.js', '.jsx', '.ts', '.tsx')):
                continue
                
            try:
                # Decode base64 content
                content = base64.b64decode(file_data['content']).decode('utf-8')
                
                # Skip empty files
                if not content.strip():
                    continue
                
                # Chunk the code
                chunks = self.smart_chunk_code(content, filename)
                all_chunks.extend(chunks)
                
            except Exception as e:
                logger.warning(f"Failed to process file {filename}: {e}")
                continue
        
        # Generate embeddings for all chunks
        if all_chunks:
            all_chunks = self.embed_chunks(all_chunks)
        
        logger.info(f"Processed {len(files_data)} files into {len(all_chunks)} embedded chunks")
        return all_chunks

# Global instance
_embedder = None

def get_embedder():
    """Get or create the global embedder instance"""
    global _embedder
    if _embedder is None:
        _embedder = CodeEmbedder()
    return _embedder
}

filepath:///E:\ragai\RAG-DEV\rag-dev-assistant\app - Copy.py /// /// ///
file code{
from flask import Flask, render_template, request, jsonify, send_from_directory
from flask_cors import CORS
import os
import logging
import base64
import json

# Create Flask app
app = Flask(__name__, static_folder='static')
CORS(app)

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@app.route('/')
def index():
    """Serve the main HTML page"""
    return send_from_directory('static', 'index.html')

@app.route('/ask', methods=['POST'])
def ask():
    """Simple text-based RAG endpoint"""
    try:
        data = request.get_json()
        query = data.get("query", "")
        codebase = data.get("codebase", "")
        obfuscated = data.get("obfuscated", "You are a helpful senior software developer assistant.")
        
        logger.info(f"Processing query: {query}")
        logger.info(f"Codebase length: {len(codebase)} characters")
        
        if not query:
            return jsonify({'error': 'Query is required'}), 400
            
        if not codebase:
            return jsonify({'error': 'Codebase is required'}), 400
        
        # Simple codebase analysis
        file_count = codebase.count('/////////')
        has_react = 'import React' in codebase or 'from "react"' in codebase
        has_typescript = '.tsx' in codebase or '.ts' in codebase
        has_hooks = 'useState' in codebase or 'useEffect' in codebase
        has_components = 'function ' in codebase or 'const ' in codebase
        
        # Create analysis result
        result = f"""## üöÄ React Code Analysis

**Your Query:** {query}

**üìä Codebase Overview:**
- Total size: {len(codebase):,} characters
- Files detected: {file_count} files
- Technology: {'React TypeScript' if has_typescript else 'React JavaScript'}
- Uses React Hooks: {'Yes' if has_hooks else 'No'}
- Has Components: {'Yes' if has_components else 'No'}

**üîç Analysis for "{query}":**

{obfuscated}

**üìù Quick Insights:**
"""

        # Add specific insights based on query
        if 'useeffect' in query.lower() or 'effect' in query.lower():
            result += """
- ‚ö†Ô∏è **useEffect Issues:** Common causes of infinite re-renders:
  1. Missing dependency array
  2. Objects/functions in dependency array
  3. State updates triggering the effect
  
- üí° **Solutions:**
  - Use useCallback for function dependencies
  - Use useMemo for object dependencies
  - Split effects by concern"""

        elif 'usestate' in query.lower() or 'state' in query.lower():
            result += """
- üì¶ **useState Best Practices:**
  1. Don't call setState in render
  2. Use functional updates for counters
  3. Group related state together
  
- üîÑ **State Updates:**
  - setState is asynchronous
  - Use functional form: setState(prev => prev + 1)"""

        elif 'performance' in query.lower() or 'slow' in query.lower():
            result += """
- üöÄ **Performance Tips:**
  1. Use React.memo for expensive components
  2. Implement useMemo for heavy calculations
  3. Use useCallback for event handlers
  4. Consider code-splitting with lazy loading"""

        elif 'typescript' in query.lower() or 'type' in query.lower():
            result += """
- üõ°Ô∏è **TypeScript in React:**
  1. Define proper interfaces for props
  2. Use union types for state
  3. Type your event handlers
  4. Leverage generic components"""

        else:
            result += f"""
Based on your {file_count} files, here are general recommendations:

- üßπ **Code Organization:** Structure components by feature
- üì± **React Patterns:** {'Using modern hooks ‚úÖ' if has_hooks else 'Consider upgrading to hooks'}
- üîß **TypeScript:** {'Already using TS ‚úÖ' if has_typescript else 'Consider adding TypeScript'}
- üéØ **Best Practices:** Keep components small and focused

**üí° Pro Tip:** Your specific query "{query}" - try asking about specific patterns, errors, or concepts!"""

        result += f"""

**üîó Related Files Analyzed:**
{', '.join([f"File {i+1}" for i in range(min(file_count, 10))])}
{'...' if file_count > 10 else ''}

---
*Analysis complete! Your code is processed locally and securely.* üîí"""

        # Base64 encode the response
        encoded = base64.b64encode(result.encode()).decode()
        return jsonify({"answer": encoded})
        
    except Exception as e:
        logger.error(f"Error: {str(e)}")
        result = f"‚ùå Error processing your request: {str(e)}"
        encoded = base64.b64encode(result.encode()).decode()
        return jsonify({"answer": encoded}), 500

@app.route('/health')
def health_check():
    """Health check endpoint"""
    return jsonify({'status': 'healthy', 'message': 'React Code Assistant is running!'})

if __name__ == '__main__':
    # Create necessary directories
    os.makedirs('static', exist_ok=True)
    os.makedirs('logs', exist_ok=True)
    
    # Run the app
    app.run(host='0.0.0.0', port=5000, debug=True)
}

filepath:///E:\ragai\RAG-DEV\rag-dev-assistant\modules\__init__.py /// /// ///
file code{
# RAG Dev Assistant Modules
__version__ = "1.0.0"
}

filepath:///E:\ragai\RAG-DEV\rag-dev-assistant\config\app_config.py /// /// ///
file code{
 

}

filepath:///E:\ragai\RAG-DEV\rag-dev-assistant\config\prompts.py /// /// ///
file code{
 

}

filepath:///E:\ragai\RAG-DEV\rag-dev-assistant\deployment\docker-compose.yml /// /// ///
file code{
 

}

filepath:///E:\ragai\RAG-DEV\rag-dev-assistant\deployment\gcp\cloudbuild.yaml /// /// ///
file code{
 

}

filepath:///E:\ragai\RAG-DEV\rag-dev-assistant\deployment\gcp\service.yaml /// /// ///
file code{
 

}

filepath:///E:\ragai\RAG-DEV\rag-dev-assistant\modules\file_processor.py /// /// ///
file code{
 

}

filepath:///E:\ragai\RAG-DEV\rag-dev-assistant\modules\prompt_manager.py /// /// ///
file code{
 

}

filepath:///E:\ragai\RAG-DEV\rag-dev-assistant\scripts\setup_db.py /// /// ///
file code{
 

}

filepath:///E:\ragai\RAG-DEV\rag-dev-assistant\scripts\test_deployment.py /// /// ///
file code{
 

}

filepath:///E:\ragai\RAG-DEV\rag-dev-assistant\static\css\styles.css /// /// ///
file code{
 

}

filepath:///E:\ragai\RAG-DEV\rag-dev-assistant\static\js\main.js /// /// ///
file code{
 

}

filepath:///E:\ragai\RAG-DEV\rag-dev-assistant\tests\test_api.py /// /// ///
file code{
 

}

filepath:///E:\ragai\RAG-DEV\rag-dev-assistant\tests\test_embedder.py /// /// ///
file code{
 

}

filepath:///E:\ragai\RAG-DEV\rag-dev-assistant\tests\test_retriever.py /// /// ///
file code{
 

}

filepath:///E:\ragai\RAG-DEV\rag-dev-assistant\tests\__init__.py /// /// ///
file code{
 

}

